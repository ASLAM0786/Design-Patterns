/**
**Intent:

**Problem:

**Solution:

**Statements:
Now Let’s try and understand the facade pattern better using a simple example. Let’s consider
a hotel. This hotel has a hotel keeper. There are a lot of restaurants inside the hotel e.g.
Veg restaurants, Non-Veg restaurants, and Veg/Non Both restaurants. You, as a client want
access to different menus of different restaurants. You do not know what are the different
menus they have. You just have access to a hotel keeper who knows his hotel well. Whichever
menu you want, you tell the hotel keeper and he takes it out of the respective restaurants
and hands it over to you. Here, the hotel keeper acts as the facade, as he hides the
complexities of the system hotel. Let’s see how it works:
**Applicability:
1-Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.
2- Use the Facade when you want to structure a subsystem into layers.
**Pros:
1- You can isolate your code from the complexity of a subsystem.
**Cons:
1-A facade can become a god object coupled to all classes of an app.
*/
#include <iostream>

int main()
{

    // TODO implementation completion pending
    std::cout << "<!------Decorator Design pattern---------!>\n";

    std::cout << "<!------------------>>>>>>>>>>>>-------------!>\n";

    return 0;
}